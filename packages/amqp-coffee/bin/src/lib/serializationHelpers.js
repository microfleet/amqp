// Generated by CoffeeScript 2.6.1
(function() {
  var getCode, isBigInt, isFloat, jspack, serializeArray, serializeBase64, serializeBuffer, serializeDate, serializeFields, serializeFloat, serializeInt, serializeLongString, serializeShortString, serializeTable, serializeValue;

  jspack = require('../jspack');

  exports.serializeFloat = serializeFloat = function(b, size, value, bigEndian) {
    var i, j, jp, k, len, len1, results, results1, x;
    jp = new jspack(bigEndian);
    switch (size) {
      case 4:
        x = jp.Pack('f', [value]);
        results = [];
        for (j = 0, len = x.length; j < len; j++) {
          i = x[j];
          results.push(b[b.used++] = i);
        }
        return results;
        break;
      case 8:
        x = jp.Pack('d', [value]);
        results1 = [];
        for (k = 0, len1 = x.length; k < len1; k++) {
          i = x[k];
          results1.push(b[b.used++] = i);
        }
        return results1;
        break;
      default:
        throw new Error("Unknown floating point size");
    }
  };

  exports.serializeInt = serializeInt = function(b, size, int) {
    if (b.used + size > b.length) {
      throw new Error("write out of bounds");
    }
    // Only 4 cases - just going to be explicit instead of looping.
    switch (size) {
      // octet
      case 1:
        return b[b.used++] = int;
      // short
      case 2:
        b[b.used++] = (int & 0xFF00) >> 8;
        return b[b.used++] = (int & 0x00FF) >> 0;
      // long
      case 4:
        b[b.used++] = (int & 0xFF000000) >> 24;
        b[b.used++] = (int & 0x00FF0000) >> 16;
        b[b.used++] = (int & 0x0000FF00) >> 8;
        return b[b.used++] = (int & 0x000000FF) >> 0;
      // long long
      case 8:
        b[b.used++] = (int & 0xFF00000000000000) >> 56;
        b[b.used++] = (int & 0x00FF000000000000) >> 48;
        b[b.used++] = (int & 0x0000FF0000000000) >> 40;
        b[b.used++] = (int & 0x000000FF00000000) >> 32;
        b[b.used++] = (int & 0x00000000FF000000) >> 24;
        b[b.used++] = (int & 0x0000000000FF0000) >> 16;
        b[b.used++] = (int & 0x000000000000FF00) >> 8;
        return b[b.used++] = (int & 0x00000000000000FF) >> 0;
      default:
        throw new Error("Bad size");
    }
  };

  exports.serializeShortString = serializeShortString = function(b, string) {
    var byteLength;
    if (typeof string !== "string") {
      throw new Error("param must be a string");
    }
    byteLength = Buffer.byteLength(string, 'utf8');
    if (byteLength > 0xFF) {
      throw new Error("String too long for 'shortstr' parameter");
    }
    if (1 + byteLength + b.used >= b.length) {
      throw new Error("Not enough space in buffer for 'shortstr'");
    }
    b[b.used++] = byteLength;
    b.write(string, b.used, 'utf8');
    return b.used += byteLength;
  };

  exports.serializeLongString = serializeLongString = function(b, string) {
    var byteLength;
    // we accept string, object, or buffer for this parameter.
    // in the when of string we serialize it to utf8.
    if (typeof string === 'string') {
      byteLength = Buffer.byteLength(string, 'utf8');
      serializeInt(b, 4, byteLength);
      b.write(string, b.used, 'utf8');
      return b.used += byteLength;
    } else if (typeof string === 'object') {
      return serializeTable(b, string);
    } else {
      // data is Buffer
      byteLength = string.length;
      serializeInt(b, 4, byteLength);
      b.write(string, b.used); // memcpy
      return b.used += byteLength;
    }
  };

  exports.serializeDate = serializeDate = function(b, date) {
    return serializeInt(b, 8, date.valueOf() / 1000);
  };

  exports.serializeBuffer = serializeBuffer = function(b, buffer) {
    serializeInt(b, 4, buffer.length);
    buffer.copy(b, b.used, 0);
    return b.used += buffer.length;
  };

  exports.serializeBase64 = serializeBase64 = function(b, buffer) {
    return serializeLongString(b, buffer.toString('base64'));
  };

  exports.serializeValue = serializeValue = function(b, value) {
    switch (typeof value) {
      case 'string':
        b[b.used++] = 'S'.charCodeAt(0);
        return serializeLongString(b, value);
      case 'number':
        if (!isFloat(value)) {
          if (isBigInt(value)) {
            // 64-bit uint
            b[b.used++] = 'l'.charCodeAt(0);
            return serializeInt(b, 8, value);
          } else {
            //32-bit uint
            b[b.used++] = 'I'.charCodeAt(0);
            return serializeInt(b, 4, value);
          }
        } else {
          //64-bit float
          b[b.used++] = 'd'.charCodeAt(0);
          return serializeFloat(b, 8, value);
        }
        break;
      case 'boolean':
        b[b.used++] = 't'.charCodeAt(0);
        return b[b.used++] = value;
      default:
        if (value instanceof Date) {
          b[b.used++] = 'T'.charCodeAt(0);
          return serializeDate(b, value);
        } else if (value instanceof Buffer) {
          b[b.used++] = 'x'.charCodeAt(0);
          return serializeBuffer(b, value);
        } else if (Array.isArray(value)) {
          b[b.used++] = 'A'.charCodeAt(0);
          return serializeArray(b, value);
        } else if (typeof value === 'object') {
          b[b.used++] = 'F'.charCodeAt(0);
          return serializeTable(b, value);
        } else {
          return this.throwError("unsupported type in amqp table = " + typeof value);
        }
    }
  };

  exports.serializeTable = serializeTable = function(b, object) {
    var endIndex, key, lengthIndex, startIndex, value;
    if (typeof object !== "object") {
      throw new Error("param must be an object");
    }
    // Save our position so that we can go back and write the length of this table
    // at the beginning of the packet (once we know how many entries there are).
    lengthIndex = b.used;
    b.used += 4; // sizeof long
    startIndex = b.used;
    for (key in object) {
      value = object[key];
      serializeShortString(b, key);
      serializeValue(b, value);
    }
    endIndex = b.used;
    b.used = lengthIndex;
    serializeInt(b, 4, endIndex - startIndex);
    return b.used = endIndex;
  };

  exports.serializeArray = serializeArray = function(b, arr) {
    var endIndex, i, j, len, lengthIndex, startIndex;
    // Save our position so that we can go back and write the byte length of this array
    // at the beginning of the packet (once we have serialized all elements).
    lengthIndex = b.used;
    b.used += 4; // sizeof long
    startIndex = b.used;
    for (j = 0, len = arr.length; j < len; j++) {
      i = arr[j];
      serializeValue(b, i);
    }
    endIndex = b.used;
    b.used = lengthIndex;
    serializeInt(b, 4, endIndex - startIndex);
    return b.used = endIndex;
  };

  exports.serializeFields = serializeFields = function(buffer, fields, args, strict) {
    var bitField, bitIndex, domain, field, i, j, param, ref, results;
    bitField = 0;
    bitIndex = 0;
    results = [];
    for (i = j = 0, ref = fields.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
      field = fields[i];
      domain = field.domain;
      if (!(args.hasOwnProperty(field.name))) {
        if (strict) {
          if (field.name.indexOf("reserved") === 0) {
            // populate default reserved values, this is to keep the code cleaner, but may be wrong
            switch (domain) {
              case 'short':
                args[field.name] = 0;
                break;
              case 'bit':
                args[field.name] = false;
                break;
              case 'shortstr':
                args[field.name] = "";
                break;
              default:
                args[field.name] = true;
            }
          } else if (field.name === "noWait") {
            // defaults noWait to false
            args[field.name] = false;
          } else {
            throw new Error("Missing field '" + field.name + "' of type '" + domain + "' while executing AMQP method '" + arguments.callee.caller.arguments[1].name + "'");
          }
        } else {
          continue;
        }
      }
      param = args[field.name];
      switch (domain) {
        case 'bit':
          if (typeof param !== "boolean") {
            throw new Error("Unmatched field " + JSON.stringify(field));
          }
          if (param) {
            bitField |= 1 << bitIndex;
          }
          bitIndex++;
          if (!fields[i + 1] || fields[i + 1].domain !== 'bit') {
            // debug('SET bit field ' + field.name + ' 0x' + bitField.toString(16))
            buffer[buffer.used++] = bitField;
            bitField = 0;
            results.push(bitIndex = 0);
          } else {
            results.push(void 0);
          }
          break;
        case 'octet':
          if (typeof param !== "number" || param > 0xFF) {
            throw new Error("Unmatched field " + JSON.stringify(field));
          }
          results.push(buffer[buffer.used++] = param);
          break;
        case 'short':
          if (typeof param !== "number" || param > 0xFFFF) {
            throw new Error("Unmatched field " + JSON.stringify(field));
          }
          serializeInt(buffer, 2, param);
          break;
        case 'long':
          if (typeof param !== "number" || param > 0xFFFFFFFF) {
            throw new Error("Unmatched field " + JSON.stringify(field));
          }
          results.push(serializeInt(buffer, 4, param));
          break;
        case 'timestamp':
        case 'longlong':
          results.push(serializeInt(buffer, 8, param));
          break;
        case 'shortstr':
          if (typeof param !== "string" || param.length > 0xFF) {
            throw new Error("Unmatched field " + JSON.stringify(field));
          }
          results.push(serializeShortString(buffer, param));
          break;
        case 'longstr':
          results.push(serializeLongString(buffer, param));
          break;
        case 'table':
          if (typeof param !== "object") {
            throw new Error("Unmatched field " + JSON.stringify(field));
          }
          results.push(serializeTable(buffer, param));
          break;
        default:
          throw new Error("Unknown domain value type " + domain);
      }
    }
    return results;
  };

  exports.isBigInt = isBigInt = function(value) {
    return value > 0xffffffff;
  };

  exports.getCode = getCode = function(dev) {
    var code1, code2, hexArray;
    hexArray = "0123456789ABCDEF".split('');
    code1 = Math.floor(dec / 16);
    code2 = dec - code1 * 16;
    return hexArray[code2];
  };

  exports.isFloat = isFloat = function(value) {
    return value === +value && value !== value | 0;
  };

}).call(this);
