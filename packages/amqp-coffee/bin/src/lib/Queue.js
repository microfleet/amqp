// Generated by CoffeeScript 2.6.1
(function() {
  // Queues
  var Channel, Queue, applyDefaults, classes, debug, defaults, methodTable, methods;

  debug = require('./config').debug('amqp:Queue');

  Channel = require('./Channel');

  defaults = require('./defaults');

  applyDefaults = require('lodash/defaults');

  ({methodTable, classes, methods} = require('./config').protocol);

  Queue = class Queue {
    /*
      @args.name(required)
      @cb function required
    */
    constructor(channel, args, cb) {
      this.bind = this.bind.bind(this);
      this.unbind = this.unbind.bind(this);
      this.messageCount = this.messageCount.bind(this);
      this.delete = this.delete.bind(this);
      debug(3, function() {
        return ["New queue", JSON.stringify(args)];
      });
      if ((args.queue == null) && (args.name != null)) {
        args.queue = args.name;
        delete args['name'];
      }
      if (args.queue == null) {
        if (cb != null) {
          cb("args.queue is required");
        }
        return;
      }
      this.queueOptions = applyDefaults(args, defaults.queue);
      this.channel = channel;
      this.taskPush = channel.taskPush;
      if (cb != null) {
        cb(null, this);
      }
    }

    declare(args = {}, cb) {
      var declareOptions, queueNameSpecified;
      queueNameSpecified = (args.queue != null) && args.queue !== "";
      if (typeof args === 'function') {
        cb = args;
        args = {};
        declareOptions = this.queueOptions;
      } else {
        declareOptions = applyDefaults(args, this.queueOptions);
      }
      this.taskPush(methods.queueDeclare, declareOptions, methods.queueDeclareOk, (err, res) => {
        if (!queueNameSpecified && (err == null) && (res.queue != null)) {
          this.queueOptions.queue = res.queue;
        }
        return typeof cb === "function" ? cb(err, res) : void 0;
      });
      return this;
    }

    bind(exchange, routingKey, opts, cb) {
      var args, queueBindOptions, queueName;
      if (typeof opts === 'function') {
        cb = opts;
        queueName = this.queueOptions.queue;
        args = {};
      } else if (typeof opts === 'string') {
        queueName = opts;
        args = {};
      // cb is either undefined or present, both are good opts
      } else if (opts !== null && typeof opts === 'object') {
        // neither string or function means its either
        args = opts.arguments || {};
        queueName = opts.queue || this.queueOptions.queue;
      } else {
        args = {};
        queueName = this.queueOptions.queue;
      }
      queueBindOptions = {
        queue: queueName,
        exchange: exchange,
        routingKey: routingKey,
        arguments: args
      };
      this.taskPush(methods.queueBind, queueBindOptions, methods.queueBindOk, cb);
      return this;
    }

    unbind(exchange, routingKey, queueName, cb) {
      var queueUnbindOptions;
      if (typeof queueName === 'string') {
        queueName = queueName;
      } else {
        cb = queueName;
        queueName = this.queueOptions.queue;
      }
      queueUnbindOptions = {
        queue: queueName,
        exchange: exchange,
        routingKey: routingKey,
        arguments: {}
      };
      this.taskPush(methods.queueUnbind, queueUnbindOptions, methods.queueUnbindOk, cb);
      return this;
    }

    messageCount(args = {}, cb) {
      var declareOptions;
      if (typeof args === 'function') {
        cb = args;
        args = {};
      }
      declareOptions = applyDefaults(args, this.queueOptions);
      return this.declare(declareOptions, function(err, res) {
        if (err != null) {
          return cb(err);
        }
        if ((res != null ? res.messageCount : void 0) != null) {
          return cb(null, res.messageCount);
        } else {
          return cb('messageCount not returned');
        }
      });
    }

    consumerCount(args = {}, cb) {
      var declareOptions;
      if (typeof args === 'function') {
        cb = args;
        args = {};
      }
      declareOptions = applyDefaults(args, this.queueOptions);
      return this.declare(declareOptions, function(err, res) {
        if (err != null) {
          return cb(err);
        }
        if ((res != null ? res.consumerCount : void 0) != null) {
          return cb(null, res.consumerCount);
        } else {
          return cb('consumerCount not returned');
        }
      });
    }

    delete(args = {}, cb) {
      var queueDeleteArgs;
      if (typeof args === 'function') {
        cb = args;
        args = {};
      }
      queueDeleteArgs = applyDefaults(args, defaults.queueDelete, {
        queue: this.queueOptions.queue
      });
      this.taskPush(methods.queueDelete, queueDeleteArgs, methods.queueDeleteOk, cb);
      return this;
    }

  };

  module.exports = Queue;

}).call(this);
