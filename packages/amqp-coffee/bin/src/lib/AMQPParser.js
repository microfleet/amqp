// Generated by CoffeeScript 2.6.1
(function() {
  var AMQPParser, EventEmitter, FrameType, Indicators, classes, debug, methodTable, methods, parseFields, parseIntFromBuffer;

  ({EventEmitter} = require('events'));

  ({Indicators, FrameType} = require('./config').constants);

  ({methodTable, classes, methods} = require('./config').protocol);

  ({parseIntFromBuffer, parseFields} = require('./parseHelpers'));

  debug = require('./config').debug('amqp:AMQPParser');

  AMQPParser = class AMQPParser extends EventEmitter {
    constructor(version, type, connection) {
      super();
      this.connection = connection;
      // send the start of the handshake....
      this.connection.connection.write("AMQP" + String.fromCharCode(0, 0, 9, 1));
      // set up some defaults, for reuse
      this.frameHeader = Buffer.allocUnsafe(7);
      this.frameHeader.used = 0;
      // set the first step in out parser
      this.parser = this.header;
    }

    execute(data) {
      // each parser will return the next parser for us to use.
      return this.parser = this.parser(data);
    }

    // Data Handlers ####################################################################
    header(data) {
      var dataLength, neededForCompleteHeader, ref, ref1;
      dataLength = data.length;
      neededForCompleteHeader = this.frameHeader.length - this.frameHeader.used;
      // copy all of our data to our frame header
      data.copy(this.frameHeader, this.frameHeader.used, 0, dataLength);
      // update where we are in the header
      this.frameHeader.used += dataLength;
      // if we have all the header data we need we're done here
      if (this.frameHeader.used >= this.frameHeader.length) {
        this.frameHeader.read = 0; // this is used to keep track of where we are with parseIntFromBuffer
        
        // What do we know from the header packet.
        this.frameType = this.frameHeader[this.frameHeader.read++];
        this.frameChannel = parseIntFromBuffer(this.frameHeader, 2);
        this.frameSize = parseIntFromBuffer(this.frameHeader, 4);
        if (this.frameSize > this.connection.frameMax) {
          if ((ref = this.connection) != null) {
            if ((ref1 = ref.connection) != null) {
              if (typeof ref1.destroy === "function") {
                ref1.destroy();
              }
            }
          }
          return this.error(`${this.frameChannel} Oversize frame size ${this.frameSize} of max ${this.connection.frameMax}`);
        }
        // setup our frameBuffer
        this.frameBuffer = Buffer.allocUnsafe(this.frameSize);
        this.frameBuffer.used = 0;
        // reset out frameHeader
        this.frameHeader.used = 0;
        return this.frame(data.slice(neededForCompleteHeader));
      } else {
        return this.header;
      }
    }

    frame(data) {
      var dataLength, neededForCompleteFrame;
      dataLength = data.length;
      neededForCompleteFrame = this.frameBuffer.length - this.frameBuffer.used;
      data.copy(this.frameBuffer, this.frameBuffer.used, 0, dataLength);
      this.frameBuffer.used += dataLength;
      // we have everything we need AND more so lets make sure we pass that through
      if (dataLength > neededForCompleteFrame) {
        return this.frameEnd(data.slice(neededForCompleteFrame));
      // we have exactly what we need for this frame
      } else if (dataLength === neededForCompleteFrame) {
        return this.frameEnd;
      } else {
        // we dont have enough info to continue so lets wait for more frame data
        return this.frame;
      }
    }

    frameEnd(data) {
      if (!(data.length > 0)) {
        return this.frameEnd;
      }
      if (data[0] !== Indicators.FRAME_END) {
        return this.error("Missing frame end marker");
      }
      switch (this.frameType) {
        case FrameType.METHOD:
          this.parseMethodFrame(this.frameChannel, this.frameBuffer);
          break;
        case FrameType.HEADER:
          this.parseHeaderFrame(this.frameChannel, this.frameBuffer);
          break;
        case FrameType.BODY:
          this.parseContent(this.frameChannel, this.frameBuffer);
          break;
        case FrameType.HEARTBEAT:
          this.emit('heartbeat');
          break;
        default:
          this.error(`Unknown frametype ${this.frameType}`);
      }
      return this.header(data.slice(1));
    }

    // Frame Parsers ################################################################
    parseMethodFrame(channel, buffer) {
      var args, classId, method, methodId;
      buffer.read = 0;
      classId = parseIntFromBuffer(buffer, 2);
      methodId = parseIntFromBuffer(buffer, 2);
      if ((methodTable[classId] == null) || (methodTable[classId][methodId] == null)) {
        return this.error(`bad classId, methodId pair: ${classId}, ${methodId}`);
      }
      method = methodTable[classId][methodId];
      args = parseFields(buffer, method.fields);
      debug(3, function() {
        return `${channel} > method ${method.name} ${JSON.stringify(args)}`;
      });
      return this.emit('method', channel, method, args);
    }

    parseHeaderFrame(channel, buffer) {
      var classIndex, classInfo, field, fields, i, j, len, properties, propertyFlags, ref, size, weight;
      buffer.read = 0;
      classIndex = parseIntFromBuffer(buffer, 2);
      weight = parseIntFromBuffer(buffer, 2);
      size = parseIntFromBuffer(buffer, 8);
      classInfo = classes[classIndex];
      propertyFlags = parseIntFromBuffer(buffer, 2);
      fields = [];
      ref = classInfo.fields;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        field = ref[i];
        if ((i + 1) % 15 === 0) {
          parseIntFromBuffer(buffer, 2);
        }
        if (propertyFlags & (1 << (15 - (i % 15)))) {
          fields.push(field);
        }
      }
      properties = parseFields(buffer, fields);
      debug(3, function() {
        return `${channel} > contentHeader ${JSON.stringify(properties)} ${size}`;
      });
      return this.emit('contentHeader', channel, classInfo, weight, properties, size);
    }

    parseContent(channel, data) {
      debug(3, function() {
        return `${channel} > content ${data.length}`;
      });
      return this.emit('content', channel, data);
    }

    error(error) {
      var parserError;
      debug(`Parser error ${error}`);
      parserError = new Error(error);
      parserError.code = 'parser';
      this.connection.emit('error', parserError);
      this.frameHeader.used = 0;
      return this.header;
    }

  };

  module.exports = AMQPParser;

}).call(this);
