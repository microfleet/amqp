// Generated by CoffeeScript 2.6.1
(function() {
  /*

  Channel Manager

  we track and manage all the channels on a connection.
  we will dynamically add and remove publish channels... maybe
  we track confirm channels and non confirm channels separately.

  */
  var ChannelManager, Consumer, Publisher, TemporaryChannel, publisherPoolSize;

  publisherPoolSize = 1;

  Publisher = require('./Publisher');

  Consumer = require('./Consumer');

  TemporaryChannel = require('./TemporaryChannel');

  ChannelManager = class ChannelManager {
    constructor(connection) {
      this.nextChannelNumber = this.nextChannelNumber.bind(this);
      this.publisherChannel = this.publisherChannel.bind(this);
      this.temporaryChannel = this.temporaryChannel.bind(this);
      this.connection = connection;
      this.channels = this.connection.channels;
      this.publisherConfirmChannels = [];
      this.publisherChannels = [];
      this.tempChannel = null;
      this.queue = null;
      this.exchange = null;
      this.channelCount = this.connection.channelCount;
    }

    nextChannelNumber() {
      var nextChannelNumber;
      this.channelCount++;
      nextChannelNumber = this.channelCount;
      return nextChannelNumber;
    }

    publisherChannel(confirm, cb) {
      var channel, i, p, pool;
      if (typeof confirm === 'function') {
        cb = confirm;
        confirm = false;
      }
      if (confirm) {
        pool = this.publisherConfirmChannels;
      } else {
        pool = this.publisherChannels;
      }
      if (pool.length < publisherPoolSize) {
        channel = this.nextChannelNumber();
        p = new Publisher(this.connection, channel, confirm);
        this.channels[channel] = p;
        pool.push(p);
        return cb(null, p.channel);
      } else {
        i = Math.floor(Math.random() * pool.length);
        return cb(null, pool[i].channel);
      }
    }

    temporaryChannel(cb) {
      var channel;
      if (this.tempChannel != null) {
        if (typeof cb === "function") {
          cb(null, this.tempChannel);
        }
        return this.tempChannel;
      }
      channel = this.nextChannelNumber();
      this.tempChannel = new TemporaryChannel(this.connection, channel, (err, res) => {
        return typeof cb === "function" ? cb(err, this.tempChannel) : void 0;
      });
      this.channels[channel] = this.tempChannel;
      return this.tempChannel;
    }

    consumerChannel(cb) {
      var channel, s;
      channel = this.nextChannelNumber();
      s = new Consumer(this.connection, channel);
      this.channels[channel] = s;
      return cb(null, channel);
    }

    channelReassign(channel) {
      var newChannelNumber;
      delete this.channels[channel.channel];
      newChannelNumber = this.nextChannelNumber();
      channel.channel = newChannelNumber;
      return this.channels[newChannelNumber] = channel;
    }

    channelClosed(channelNumber) {
      return delete this.channels[channelNumber];
    }

    isChannelClosed(channelNumber) {
      return !this.channels.hasOwnProperty(channelNumber);
    }

  };

  module.exports = ChannelManager;

}).call(this);
