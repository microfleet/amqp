// Generated by CoffeeScript 2.6.1
(function() {
  // Exchange
  var CONSUMER_STATES_CLOSED, CONSUMER_STATE_CHANNEL_CLOSED, CONSUMER_STATE_CLOSED, CONSUMER_STATE_CONNECTION_CLOSED, CONSUMER_STATE_OPEN, CONSUMER_STATE_OPENING, CONSUMER_STATE_USER_CLOSED, Channel, Consumer, MaxEmptyFrameSize, applyDefaults, async, bson, classes, clone, debug, defaults, extend, methodTable, methods, os, pickBy,
    boundMethodCheck = function(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new Error('Bound instance method accessed before binding'); } },
    indexOf = [].indexOf;

  os = require('os');

  debug = require('./config').debug('amqp:Consumer');

  Channel = require('./Channel');

  async = require('async');

  defaults = require('./defaults');

  applyDefaults = require('lodash/defaults');

  extend = require('lodash/extend');

  clone = require('lodash/clone');

  pickBy = require('lodash/pickBy');

  bson = require('bson');

  ({methodTable, classes, methods} = require('./config').protocol);

  ({MaxEmptyFrameSize} = require('./config').constants);

  CONSUMER_STATE_OPEN = 'open';

  CONSUMER_STATE_OPENING = 'opening';

  CONSUMER_STATE_CLOSED = 'closed';

  CONSUMER_STATE_USER_CLOSED = 'user_closed';

  CONSUMER_STATE_CHANNEL_CLOSED = 'channel_closed';

  CONSUMER_STATE_CONNECTION_CLOSED = 'connection_closed';

  CONSUMER_STATES_CLOSED = [CONSUMER_STATE_CLOSED, CONSUMER_STATE_USER_CLOSED, CONSUMER_STATE_CONNECTION_CLOSED, CONSUMER_STATE_CHANNEL_CLOSED];

  Consumer = class Consumer extends Channel {
    constructor(connection, channel) {
      debug(2, function() {
        return `channel open for consumer ${channel}`;
      });
      super(connection, channel);
      this.close = this.close.bind(this);
      this.cancel = this.cancel.bind(this);
      // Private
      this._consume = this._consume.bind(this);
      this._basicConsumePreflight = this._basicConsumePreflight.bind(this);
      this._consumerStateOpenPreflight = this._consumerStateOpenPreflight.bind(this);
      this._channelOpen = this._channelOpen.bind(this);
      this._channelClosed = this._channelClosed.bind(this);
      this._onContent = this._onContent.bind(this);
      this.consumerState = CONSUMER_STATE_CLOSED;
      this.messageHandler = null;
      this.incomingMessage = null;
      this.outstandingDeliveryTags = {};
      return this;
    }

    consume(queueName, options, messageHandler, cb) {
      var consumeOptions, providedOptions, qosOptions, ref;
      if (typeof options === 'function') {
        if (typeof messageHandler === 'function') {
          cb = messageHandler;
        }
        messageHandler = options;
        options = {};
      }
      this.consumerTag = (ref = options.consumerTag) != null ? ref : `${os.hostname()}-${process.pid}-${Date.now()}`;
      debug(2, () => {
        return `Consuming to ${queueName} on channel ${this.channel} ${this.consumerTag}`;
      });
      this.consumerState = CONSUMER_STATE_OPENING;
      if (options.prefetchCount != null) {
        // this should be a qos channel and we should expect ack's on messages
        this.qos = true;
        providedOptions = {
          prefetchCount: options.prefetchCount
        };
        if (options.global != null) {
          providedOptions['global'] = options.global;
        }
        qosOptions = applyDefaults(providedOptions, defaults.basicQos);
        options.noAck = options.noAck || false;
        delete options.prefetchCount;
      } else {
        this.qos = false;
        options.noAck = true;
      }
      // do not mutate original opts
      consumeOptions = applyDefaults({}, options, defaults.basicConsume);
      consumeOptions.queue = queueName;
      consumeOptions.consumerTag = this.consumerTag;
      if (messageHandler != null) {
        this.messageHandler = messageHandler;
      }
      if (this.messageHandler == null) {
        return typeof cb === "function" ? cb("No message handler") : void 0;
      }
      this.consumeOptions = consumeOptions;
      this.qosOptions = qosOptions;
      this._consume(cb);
      return this;
    }

    close(cb) {
      boundMethodCheck(this, Consumer);
      return this.cancel(() => {
        this.consumerState = CONSUMER_STATE_USER_CLOSED;
        super.close();
        return typeof cb === "function" ? cb() : void 0;
      });
    }

    cancel(cb) {
      var ref;
      boundMethodCheck(this, Consumer);
      if (!(ref = this.consumerState, indexOf.call(CONSUMER_STATES_CLOSED, ref) >= 0)) {
        return this.taskPushPreflight(methods.basicCancel, {
          consumerTag: this.consumerTag,
          noWait: false
        }, methods.basicCancelOk, this._consumerStateOpenPreflight, cb);
      } else {
        return typeof cb === "function" ? cb() : void 0;
      }
    }

    pause(cb) {
      var ref;
      if (!(ref = this.consumerState, indexOf.call(CONSUMER_STATES_CLOSED, ref) >= 0)) {
        return this.cancel((err, res) => {
          // should pause be a different state?
          this.consumerState = CONSUMER_STATE_USER_CLOSED;
          return typeof cb === "function" ? cb(err, res) : void 0;
        });
      } else {
        return typeof cb === "function" ? cb() : void 0;
      }
    }

    resume(cb) {
      var ref;
      if (ref = this.consumerState, indexOf.call(CONSUMER_STATES_CLOSED, ref) >= 0) {
        return this._consume(cb);
      } else {
        return typeof cb === "function" ? cb() : void 0;
      }
    }

    flow(active, cb) {
      if (active) {
        return this.resume(cb);
      } else {
        return this.pause(cb);
      }
    }

    setQos(prefetchCount, cb) {
      var global, qosOptions, ref, ref1, ref2, ref3;
      if (typeof prefetchCount === 'function') {
        cb = prefetchCount;
        qosOptions = this.qosOptions;
      } else {
        // if our prefetch count has changed and we're rabbit version > 3.3.*
        // Rabbitmq 3.3.0 changes the behavior of qos.  we default to gloabl true in this case.
        if (prefetchCount !== this.qosOptions.prefetchCount && ((ref = this.connection.serverProperties) != null ? ref.product : void 0) === 'RabbitMQ' && (((ref1 = this.connection.serverProperties) != null ? (ref2 = ref1.capabilities) != null ? ref2.per_consumer_qos : void 0 : void 0) === true || ((ref3 = this.connection.serverProperties) != null ? ref3.version : void 0) === "3.3.0")) {
          global = true;
        }
        qosOptions = applyDefaults({prefetchCount, global}, this.qosOptions);
      }
      return this.taskPush(methods.basicQos, qosOptions, methods.basicQosOk, cb);
    }

    _consume(cb) {
      boundMethodCheck(this, Consumer);
      return async.series([
        (next) => {
          if (this.qos) {
            return this.setQos(next);
          } else {
            return next();
          }
        },
        (next) => {
          return this.taskQueuePushRaw({
            type: 'method',
            method: methods.basicConsume,
            args: this.consumeOptions,
            okMethod: methods.basicConsumeOk,
            preflight: this._basicConsumePreflight
          },
        next);
        },
        (next) => {
          this.consumerState = CONSUMER_STATE_OPEN;
          return next();
        }
      ], cb);
    }

    _basicConsumePreflight() {
      boundMethodCheck(this, Consumer);
      return this.consumerState !== CONSUMER_STATE_OPEN;
    }

    _consumerStateOpenPreflight() {
      boundMethodCheck(this, Consumer);
      return this.consumerState === CONSUMER_STATE_OPEN;
    }

    _channelOpen() {
      boundMethodCheck(this, Consumer);
      if ((this.consumeOptions != null) && this.consumerState === CONSUMER_STATE_CONNECTION_CLOSED) {
        return this._consume();
      }
    }

    _channelClosed(reason) {
      boundMethodCheck(this, Consumer);
      // if we're reconnecting it is approiate to emit the error on reconnect, this is specifically useful
      // for auto delete queues
      if (this.consumerState === CONSUMER_STATE_CHANNEL_CLOSED) {
        if (reason == null) {
          reason = {};
        }
        this.emit('error', reason);
      }
      this.outstandingDeliveryTags = {};
      if (this.connection.state === 'open' && this.consumerState === CONSUMER_STATE_OPEN) {
        this.consumerState = CONSUMER_STATE_CHANNEL_CLOSED;
        return this._consume();
      } else {
        return this.consumerState = CONSUMER_STATE_CONNECTION_CLOSED;
      }
    }

    multiAck(deliveryTag) {
      var basicAckOptions;
      if (this.qos && !this.consumeOptions.noAck) {
        this.outstandingDeliveryTags = pickBy(this.outstandingDeliveryTags, function(value, key) {
          return key > deliveryTag;
        });
        if (this.state === 'open') {
          basicAckOptions = {
            deliveryTag,
            multiple: true
          };
          return this.connection._sendMethod(this.channel, methods.basicAck, basicAckOptions);
        }
      }
    }

    // QOS RELATED Callbacks
    ack() {
      var basicAckOptions;
      if (this.subscription.qos && !this.subscription.consumeOptions.noAck && (this.subscription.outstandingDeliveryTags[this.deliveryTag] != null)) {
        delete this.subscription.outstandingDeliveryTags[this.deliveryTag];
        if (this.subscription.state === 'open') {
          basicAckOptions = {
            deliveryTag: this.deliveryTag,
            multiple: false
          };
          return this.subscription.connection._sendMethod(this.subscription.channel, methods.basicAck, basicAckOptions);
        }
      }
    }

    reject() {
      var basicAckOptions;
      if (this.subscription.qos && !this.subscription.consumeOptions.noAck && (this.subscription.outstandingDeliveryTags[this.deliveryTag] != null)) {
        delete this.subscription.outstandingDeliveryTags[this.deliveryTag];
        if (this.subscription.state === 'open') {
          basicAckOptions = {
            deliveryTag: this.deliveryTag,
            requeue: false
          };
          return this.subscription.connection._sendMethod(this.subscription.channel, methods.basicReject, basicAckOptions);
        }
      }
    }

    retry() {
      var basicAckOptions;
      if (this.subscription.qos && !this.subscription.consumeOptions.noAck && (this.subscription.outstandingDeliveryTags[this.deliveryTag] != null)) {
        delete this.subscription.outstandingDeliveryTags[this.deliveryTag];
        if (this.subscription.state === 'open') {
          basicAckOptions = {
            deliveryTag: this.deliveryTag,
            requeue: true
          };
          return this.subscription.connection._sendMethod(this.subscription.channel, methods.basicReject, basicAckOptions);
        }
      }
    }

    // CONTENT HANDLING
    _onMethod(channel, method, args) {
      var cancelError;
      debug(3, function() {
        return `onMethod ${method.name}, ${JSON.stringify(args)}`;
      });
      switch (method) {
        case methods.basicDeliver:
          delete args['consumerTag'];
          if (this.qos) {
            return this.incomingMessage = args;
          } else {
            return this.incomingMessage = args;
          }
          break;
        case methods.basicCancel:
          debug(1, function() {
            return "basicCancel";
          });
          this.consumerState = CONSUMER_STATE_CLOSED;
          if (this.listeners('cancel').length > 0) {
            return this.emit('cancel', "Server initiated basicCancel");
          } else {
            cancelError = new Error("Server initiated basicCancel");
            cancelError.code = 'basicCancel';
            return this.emit('error', cancelError);
          }
      }
    }

    _onContentHeader(channel, classInfo, weight, properties, size) {
      debug(3, function() {
        return `_onContentHeader ${JSON.stringify(properties)} ${size}`;
      });
      this.incomingMessage = extend(this.incomingMessage, {weight, properties, size});
      // if we're only expecting one packet lets just copy the buffer when we get it
      // otherwise lets create a new incoming data buffer and pre alloc the space
      if (size > this.connection.frameMax - MaxEmptyFrameSize) {
        this.incomingMessage.data = Buffer.allocUnsafe(size);
        this.incomingMessage.data.used = 0;
      }
      if (size === 0) {
        return this._onContent(channel, Buffer.allocUnsafe(0));
      }
    }

    _onContent(channel, data) {
      var message, ref, ref1, ref2, ref3;
      boundMethodCheck(this, Consumer);
      if ((this.incomingMessage.data == null) && this.incomingMessage.size === data.length) {
        // if our size is equal to the data we have, just replace the data object
        this.incomingMessage.data = data;
      } else {
        // if there are multiple packets just copy the data starting from the last used bit.
        data.copy(this.incomingMessage.data, this.incomingMessage.data.used);
        this.incomingMessage.data.used += data.length;
      }
      if (this.incomingMessage.data.used >= this.incomingMessage.size || this.incomingMessage.size === 0) {
        message = clone(this.incomingMessage);
        message.raw = this.incomingMessage.data;
        // DEFINE GETTERS ON THE DATA FIELD WHICH RETURN A COPY OF THE RAW DATA
        if (((ref = this.incomingMessage.properties) != null ? ref.contentType : void 0) === "application/json") {
          // we use defineProperty here because we want to keep our original message intact and dont want to pass around a special message
          Object.defineProperty(message, "data", {
            get: function() {
              var e;
              try {
                return JSON.parse(message.raw.toString());
              } catch (error) {
                e = error;
                console.error(e);
                return message.raw;
              }
            }
          });
        } else if (((ref1 = this.incomingMessage.properties) != null ? ref1.contentType : void 0) === "application/bson") {
          // we use defineProperty here because we want to keep our original message intact and dont want to pass around a special message
          Object.defineProperty(message, "data", {
            get: function() {
              var e;
              try {
                return bson.deserialize(message.raw);
              } catch (error) {
                e = error;
                console.error(e);
                return message.raw;
              }
            }
          });
        } else if (((ref2 = this.incomingMessage.properties) != null ? ref2.contentType : void 0) === "string/utf8") {
          // we use defineProperty here because we want to keep our original message intact and dont want to pass around a special message
          Object.defineProperty(message, "data", {
            get: function() {
              var e;
              try {
                return message.raw.toString('utf8');
              } catch (error) {
                e = error;
                console.error(e);
                return message.raw;
              }
            }
          });
        } else if (this.incomingMessage.size === 0 && ((ref3 = this.incomingMessage.properties) != null ? ref3.contentType : void 0) === "application/undefined") {
          // we use defineProperty here because we want to keep our original message intact and dont want to pass around a special message
          Object.defineProperty(message, "data", {
            get: function() {
              return void 0;
            }
          });
        } else {
          Object.defineProperty(message, "data", {
            get: function() {
              return message.raw;
            }
          });
        }
        if (this.qos) {
          message.ack = this.ack;
          message.reject = this.reject;
          message.retry = this.retry;
          message.subscription = this;
        }
        this.outstandingDeliveryTags[this.incomingMessage.deliveryTag] = true;
        return this.messageHandler(message);
      }
    }

  };

  module.exports = Consumer;

}).call(this);
