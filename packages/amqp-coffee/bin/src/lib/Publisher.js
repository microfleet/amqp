// Generated by CoffeeScript 2.6.1
(function() {
  // Publisher
  var BasicReturnError, Channel, Publisher, applyDefaults, classes, clone, debug, defaults, methodTable, methods,
    boundMethodCheck = function(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new Error('Bound instance method accessed before binding'); } };

  debug = require('./config').debug('amqp:Publisher');

  Channel = require('./Channel');

  defaults = require('./defaults');

  clone = require('lodash/clone');

  applyDefaults = require('lodash/defaults');

  ({BasicReturnError} = require('./Errors'));

  ({methodTable, classes, methods} = require('./config').protocol);

  Publisher = class Publisher extends Channel {
    constructor(connection, channel, confirm) {
      super(connection, channel);
      this.confirmMode = this.confirmMode.bind(this);
      this._channelClosed = this._channelClosed.bind(this);
      this.seqCallbacks = new Map(); // publisher confirms
      this.confirm = confirm != null ? confirm : false;
      this.currentMethod = null;
      this.currentArgs = null;
      if (this.confirm) {
        this.confirmMode();
      }
      return this;
    }

    confirmMode(cb) {
      boundMethodCheck(this, Publisher);
      this.confirmState = 'opening';
      return this.taskPush(methods.confirmSelect, {
        noWait: false
      }, methods.confirmSelectOk, () => {
        this.confirmState = 'open';
        this.confirm = true;
        this.seq = 1;
        if (cb != null) {
          cb();
        }
        return this.emit('confirm');
      });
    }

    _channelClosed(message) {
      var cb, ref;
      boundMethodCheck(this, Publisher);
      this.confirmState = 'closed';
      if (message == null) {
        message = "Channel closed, try again";
      }
      ref = this.seqCallbacks.values();
      for (cb of ref) {
        if (typeof cb === 'function') {
          cb(message);
        }
      }
      this.seqCallbacks = new Map();
      if (this.confirm) {
        return this.confirmMode();
      }
    }

    publish(exchange, routingKey, data, options, cb) {
      var thisSequenceNumber, waitFor;
      if (typeof options === 'function') {
        cb = options;
        options = {};
      }
      if (options == null) {
        options = {};
      } else {
        options = clone(options);
      }
      if (this.state !== "open" || (this.confirm && this.confirmState !== "open")) {
        if (this.state === "opening" || this.state === "closed" || (this.confirm && this.confirmState === 'opening')) {
          if (this.confirm) {
            waitFor = 'confirm';
          } else {
            waitFor = 'open';
          }
          return this.once(waitFor, () => {
            return this.publish(exchange, routingKey, data, options, cb);
          });
        } else {
          if (cb) {
            return cb(new Error(`Channel is closed and will not re-open? ${this.state} ${this.confirm} ${this.confirmState}`));
          }
        }
      }
      // data must be a buffer
      if (typeof data === 'string') {
        options.contentType = 'string/utf8';
        data = Buffer.from(data, 'utf8');
      } else if (typeof data === 'object' && !(data instanceof Buffer)) {
        if (options.contentType != null) {
          debug(1, function() {
            return `contentType specified but data isn't a buffer, ${JSON.stringify(options)}`;
          });
          if (cb != null) {
            cb("contentType specified but data isn't a buffer");
            return;
          }
        }
        // default use JSON
        data = Buffer.from(JSON.stringify(data), 'utf8');
        options.contentType = 'application/json';
      // data = BSON.serialize data
      // options.contentType = 'application/bson'
      } else if (data === void 0) {
        data = Buffer.allocUnsafe(0);
        options.contentType = 'application/undefined';
      }
      if (this.confirm) {
        // increment this as the final step before publishing, to make sure we're in sync with the server
        thisSequenceNumber = this.seq++;
      }
      // Apply default options after we deal with potentially converting the data
      options = applyDefaults(options, defaults.basicPublish);
      options.exchange = exchange;
      options.routingKey = routingKey;
      // This is to tie back this message as failed if it failed in confirm mode with a mandatory or immediate publish
      if (this.confirm && (cb != null) && (options.mandatory || options.immediate)) {
        if (options.headers == null) {
          options.headers = {};
        }
        options.headers['x-seq'] = thisSequenceNumber;
      }
      this.queuePublish(methods.basicPublish, data, options);
      if (this.confirm && (cb != null)) {
        debug(4, function() {
          return JSON.stringify({exchange, routingKey, data, options, thisSequenceNumber});
        });
        return this._waitForSeq(thisSequenceNumber, cb);
      } else {
        debug(4, function() {
          return JSON.stringify({
            exchange,
            routingKey,
            data,
            options,
            noConfirm: true
          });
        });
        if (cb != null) {
          return setImmediate(cb);
        }
      }
    }

    _onMethod(channel, method, args) {
      this.currentMethod = method;
      this.currentArgs = args;
      switch (method) {
        case methods.basicAck:
          if (this.confirm) {
            // debug 4, () => return JSON.stringify args
            return this._gotSeq(args.deliveryTag, args.multiple);
          }
      }
    }

    _onContentHeader(channel, classInfo, weight, properties, size) {
      var ref;
      switch (this.currentMethod) {
        case methods.basicReturn:
          if (((ref = properties.headers) != null ? ref['x-seq'] : void 0) != null) {
            return this._gotSeq(properties.headers['x-seq'], false, new BasicReturnError(this.currentArgs));
          }
      }
    }

    _onContent(channel, data) {}

    // Content is not needed on a basicReturn
    _waitForSeq(seq, cb) {
      if (typeof cb === 'function') {
        return this.seqCallbacks.set(seq, cb);
      } else {
        debug("callback requested for publish that isn't a function");
        return console.error(cb);
      }
    }

    _gotSeq(seq, multi, err = null) {
      var key, ref, results;
      if (multi) {
        ref = this.seqCallbacks.keys();
        results = [];
        for (key of ref) {
          if (key <= seq) {
            this.seqCallbacks.get(key)(err);
            results.push(this.seqCallbacks.delete(key));
          } else {
            results.push(void 0);
          }
        }
        return results;
      } else {
        if (this.seqCallbacks.has(seq)) {
          this.seqCallbacks.get(seq)(err);
        } else {
          debug(3, function() {
            return `got a seq for ${seq} but that callback either doesn't exist or was already called or was returned`;
          });
        }
        return this.seqCallbacks.delete(seq);
      }
    }

  };

  module.exports = Publisher;

}).call(this);
